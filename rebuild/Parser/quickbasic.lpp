
D			[0-9]
L			[a-zA-Z]



%x REMARK
%option c++
%option yyclass="yy::basicscanner"
%option nodefault
%option noyywrap



%{
    #include <string>

    #include "quickbasic.h"
    #include "quickbasic.hpp"
    #include "location.hh"
    #include "quickbasic.tab.h"

    // define yyterminate as this instead of NULL
    #define RETTOKEN(X) return( yy::parser::token::X);
    #define yyterminate() return( yy::parser::token_type::END);
    
    
%}

%{
    // Code run each time yylex is called.
%}


%%



"step"		{   RETTOKEN(STEP); }
"print"		{   RETTOKEN(PRINT); }
"input"		{   RETTOKEN(INPUT); }
"let"		{   RETTOKEN(LET); }
"if"		{   RETTOKEN(IF); }
"else"		{   RETTOKEN(ELSE); }
"then"		{   RETTOKEN(THEN); }
"goto"		{   RETTOKEN(GOTO); }
"for"			{  RETTOKEN(FOR); }
"next"		{  RETTOKEN(NEXT); }
"to"			{  RETTOKEN(TO); }
"end"			{  RETTOKEN(END); }
"rem"			{ BEGIN(REMARK); RETTOKEN(REM); }
"cls"			{  RETTOKEN(CLS); }
"list"			{  RETTOKEN(LIST); }
"run"			{  RETTOKEN(RUN); }



<REMARK>"\n" { BEGIN(0); }
<REMARK>.* {  yylval->stringVal = yytext;
				RETTOKEN(REMARK_RECORD);  }
"#"			{ BEGIN(REMARK); RETTOKEN(REM); }

{L}		{  yylval->stringVal = yytext;
    RETTOKEN(VAR); }

{L}"$"	{    yylval->stringVal  = yytext;
    RETTOKEN(SVAR); }

{D}+		{  yylval->numVal = atoi(yytext);
    RETTOKEN(NUMBER); }

{D}*"."{D}+		{yylval->numVal = atof(yytext);
				RETTOKEN(REAL_NUMBER); }


\"(\\.|[^\\"])*\"	{ std::string temp = yytext; yylval->stringVal=temp.substr(1,temp.size()-2); RETTOKEN(STRING_LITERAL); }


[ \t\v\n\f]		{  }
.			{ /* ignore bad characters */ }

%%



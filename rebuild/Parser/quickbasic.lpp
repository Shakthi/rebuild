
D			[0-9]
L			[a-zA-Z]



%x REMARK
%option noyywrap nounput batch debug noinput


%{
    #include <string>
    #include "quickbasic.h"
    #include "quickbasic.tab.h"
    #include "location.hh"


    #define RETTOKEN(X) return( yy::parser::token::X);
    
    
    # define YY_DECL					\
    yy::parser::token_type                         \
    yylex (yy::parser::semantic_type * yylval,      \
    yy::parser::location_type* yylloc)
    // ... and declare it for the parser's sake.
    
    
    /* define yyterminate as this instead of NULL */
    #define yyterminate() return( yy::parser::token_type::END )
%}

%{
    // Code run each time yylex is called.
%}


%%



"step"		{   RETTOKEN(STEP); }
"print"		{   RETTOKEN(PRINT); }
"input"		{   RETTOKEN(INPUT); }
"let"		{   RETTOKEN(LET); }
"if"		{   RETTOKEN(IF); }
"else"		{   RETTOKEN(ELSE); }
"then"		{   RETTOKEN(THEN); }
"goto"		{   RETTOKEN(GOTO); }
"for"			{  RETTOKEN(FOR); }
"next"		{  RETTOKEN(NEXT); }
"to"			{  RETTOKEN(TO); }
"end"			{  RETTOKEN(END); }
"rem"			{ BEGIN(REMARK); RETTOKEN(REM); }
"cls"			{  RETTOKEN(CLS); }
"list"			{  RETTOKEN(LIST); }
"run"			{  RETTOKEN(RUN); }



<REMARK>"\n" { BEGIN(0); }
<REMARK>.* {  yylval->stringVal = yytext;
				RETTOKEN(REMARK_RECORD);  }
"#"			{ BEGIN(REMARK); RETTOKEN(REM); }

{L}		{  yylval->stringVal = yytext;
    RETTOKEN(VAR); }

{L}"$"	{    yylval->stringVal  = yytext;
    RETTOKEN(SVAR); }

{D}+		{  yylval->numVal = atoi(yytext);
    RETTOKEN(NUMBER); }

{D}*"."{D}+		{yylval->numVal = atof(yytext);
				RETTOKEN(REAL_NUMBER); }


\"(\\.|[^\\"])*\"	{ std::string temp = yytext; yylval->stringVal=temp.substr(1,temp.size()-2); RETTOKEN(STRING_LITERAL); }


[ \t\v\n\f]		{  }
.			{ /* ignore bad characters */ }

%%



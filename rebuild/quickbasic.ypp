%{
    
#include<string>
#include<cstring>
#include<iostream>
#include<vector>
#include<map>


#include "quickbasic.h"
#include "AST.hpp"

std::map<std::string,Value> varTable;





#define YYERROR_VERBOSE 1
#if YYBISON
int yylex();
void yyerror(Statement ** statementOut,const char *);

#endif
%}

%start line

%parse-param { Statement ** statementOut}

%token PRINT INPUT LET IF ELSE THEN GOTO FOR NEXT TO END  STEP
ELLIPSIS REM CLS LIST RUN
%token <stringVal> VAR SVAR
%token <stringVal> STRING_LITERAL STATEMENT_RECORD REMARK_RECORD
%token <numVal> NUMBER REAL_NUMBER

%type <numVal> numexpr lineNumber
%type <stringVal> strexpr inputItem
%type <boolVal> boolExression
%type <nodeVal> inputList forStataement nextStatement

%destructor { delete $$ ;} inputList forStataement nextStatement


%left '='  '>' '<'
%left '+' '-'
%left '*' '/'
%left '%'




%%

line    :   statement {
    *statementOut = $$.nodeVal;

}

        |   command
        ;

command : listCommand | runCommand;



lineNumber : NUMBER;
runCommand : RUN    {  std::cout<<"Run to be implemnted"<<std::endl;}
;

statement   :
    printStatement
|   letStatement
|   inputStatement
|   endstatement
|  ifstatment
|  forStataement
|  nextStatement
| remStatement
|   clearStatement
| gotoStament
;


remStatement : REM REMARK_RECORD {}
;


gotoStament  : GOTO NUMBER {  std::cout<<"GOTO to be implemnted"<<std::endl; }
;

clearStatement : CLS { std::cout<<"CLS to be implemnted"<<std::endl;/*  DisplayConsole.Clear();  */}
;
listCommand : LIST { std::cout<<"LIST to be implemnted"<<std::endl;  /*foreach(var aline in interpreter.statementRecord { interpreter.PrintBuffer(""+aline.Key +":");  interpreter.PrintLnBuffer(aline.Value);} */ }
;

ifstatment : IF boolExression THEN GOTO NUMBER { std::cout<<"IF to be implemnted"<<std::endl; /*if($2) interpreter.jumpAddress = (int)$5; */}
;

printStatement : PRINT printlist    { std::cout<<std::endl;  /* interpreter.PrintBuffer("\n"); */}
;

printlist   :   printItem
|   printlist ';' printItem
;

printItem   :   strexpr   {   std::cout<<$1;   }
|   numexpr        {  std::cout<<$1;   }
;



letStatement     : LET VAR '=' numexpr  {
    
    Value value;
    value.valutype = Value::Evaluetype::floattype;
    value.numVal = $4;
    varTable[$2]=value;
    printf("///let %s = %f\n",$2.c_str(),$4);
    
}
| LET SVAR '=' strexpr {
    Value value;
    value.valutype = Value::Evaluetype::stringtype;
    value.stringVal = $4;
    varTable[$2]=value;
    printf("///let %s = \"%s\"\n",$2.c_str(),$4.c_str());

}

;


endstatement    : END { $$.nodeVal = new EndStatement(); }
;

inputStatement  : INPUT inputList { $$.nodeVal=$2;}
| INPUT STRING_LITERAL ';'  inputList
{
    auto readnode = static_cast<ReadStatement*>($4);
    readnode->prompt = $2;
    $$.nodeVal=readnode;
}
;

inputList : inputItem
{
    auto readnode = new ReadStatement();
    readnode->variableList.push_back($1);
    $$=readnode;

}
| inputList ';' inputItem
{

    auto readnode = static_cast<ReadStatement*>($1);
    readnode->variableList.push_back($3);
    $$ = $1;
}
;

inputItem       : VAR|SVAR;


forStataement 	: FOR VAR '=' numexpr TO numexpr  {
    
    std::string varName = $2;
    float step = 1;
    
    ForStatment::ForBlock forBlock;
    
    forBlock.forVar = varName;
    forBlock.forBegin = $4;
    forBlock.forStep = step;
    forBlock.forEnd = $6;
    
    auto fornode = new ForStatment();
    fornode->forBlock = forBlock;
    $$=fornode;


    
}
| FOR VAR '=' numexpr TO numexpr STEP numexpr
{
    std::string varName = $2;
    float step = $8;
    
    ForStatment::ForBlock forBlock;
    
    forBlock.forVar = varName;
    forBlock.forBegin = $4;
    forBlock.forStep = step;
    forBlock.forEnd = $6;
    
    auto fornode = new ForStatment();
    fornode->forBlock = forBlock;
    $$=fornode;
}
;



nextStatement   : NEXT VAR {
    
    auto node = new NextStatement();
    $$=node;
    
    
    
  /*  List<Interpreter.forPoints> newList = new List<Interpreter.forPoints>(interpreter.forRegister);
    newList.Reverse();
    bool found=false;
    std::string varName = $2;
    foreach(var fr in newList)
    {
        if(fr.variable == $2)
        {
            found = true;
            if(fr.finalValue >=  interpreter.varTable[varName] )
            break;
            interpreter.varTable[varName]  +=fr.step;
            interpreter.jumpAddress =  fr.lineNo+1;
            break;
        }
        
        
    }
    if(!found)
    interpreter.PrintBuffer("Error in search of I");
    */
}
;






boolExression : numexpr '=' numexpr {   $$ = ($1 == $3); }
| numexpr '>' numexpr {   $$ = ($1 > $3); }
| numexpr '<' numexpr {   $$ = ($1 < $3); }
| strexpr '=' strexpr {   $$ = ($1 == $3); }
;




strexpr     : '(' strexpr ')'
{
    $$ = $2;
}
| strexpr '+' strexpr
{
    
    $$=$1+$3;
    
    
}
| STRING_LITERAL
| SVAR { $$ =  varTable[$1].stringVal;  }

;





numexpr    :   '(' numexpr ')'
{
    $$ = $2;
}
|   numexpr '*' numexpr
{
    $$ = $1 * $3;
}
|   numexpr '/' numexpr
{
    $$ = $1 / $3;
}
|   numexpr '%' numexpr
{
 //   $$ = $1 % $3;
}
|   numexpr '+' numexpr
{
    $$ = $1 + $3;
}
|   numexpr '-' numexpr
{
    $$ = $1 - $3;
}

|NUMBER
|REAL_NUMBER
|VAR    { $$ = varTable[$1].numVal;  }
;



%%
void yyerror( Statement** statement, const char * error)
{
    *statement = new ErrorStatement(error);
    

}

extern "C" int yywrap()
{
    return 1;
}

/*
 Parser(Scanner scanner,
Interpreter interpreter)
: base(scanner)
{
    this.interpreter = interpreter;
    
}
*/
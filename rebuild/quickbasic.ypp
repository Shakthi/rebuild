%{
    
#include<string>
#include<cstring>
#include<iostream>
#include<vector>
#include<map>


#include "Logger.hpp"
#include "quickbasic.h"
#include "AST.hpp"


std::map<std::string,Value> varTable;
Rlog trace("trace");




#define YYERROR_VERBOSE 1
#if YYBISON
int yylex();
void yyerror(Statement ** statementOut,const char *);

#endif
%}

%start line

%parse-param { Statement ** statementOut}

%token PRINT INPUT LET IF ELSE THEN GOTO FOR NEXT TO END  STEP
ELLIPSIS REM CLS LIST RUN
%token <stringVal> VAR SVAR
%token <stringVal> STRING_LITERAL STATEMENT_RECORD REMARK_RECORD
%token <numVal> NUMBER REAL_NUMBER

%type <numVal> lineNumber
%type <expression> numexpr printItem printlist strexpr

%type <stringVal>  inputItem
%type <boolVal> boolExression
%type <nodeVal> inputList forStataement nextStatement printStatement letStatement

%destructor { delete $$ ;} inputList forStataement nextStatement printStatement numexpr


%left '='  '>' '<'
%left '+' '-'
%left '*' '/'
%left '%'




%%

line    :   statement {
    *statementOut = $$.nodeVal;

}

        |   command
        ;

command : listCommand | runCommand;



lineNumber : NUMBER;
runCommand : RUN    {  std::cout<<"Run to be implemnted"<<std::endl;}
;

statement   :
    printStatement
|   letStatement
|   inputStatement
|   endstatement
|  ifstatment
|  forStataement
|  nextStatement
| remStatement
|   clearStatement
| gotoStament
;



remStatement : REM REMARK_RECORD {  auto var= new RemarkStatement;  var->comments= $2; $$.nodeVal = var; }
;


gotoStament  : GOTO NUMBER {  std::cout<<"GOTO to be implemnted"<<std::endl; }
;

clearStatement : CLS { std::cout<<"CLS to be implemnted"<<std::endl;/*  DisplayConsole.Clear();  */}
;
listCommand : LIST { std::cout<<"LIST to be implemnted"<<std::endl;  /*foreach(var aline in interpreter.statementRecord { interpreter.PrintBuffer(""+aline.Key +":");  interpreter.PrintLnBuffer(aline.Value);} */ }
;

ifstatment : IF boolExression THEN GOTO NUMBER { std::cout<<"IF to be implemnted"<<std::endl; /*if($2) interpreter.jumpAddress = (int)$5; */}
;

printStatement : PRINT printlist    {
    
    auto printnode = new PrintStatement();
    auto a  = static_cast<ExpressionList*>$2;
    printnode->printitems = std::move(a->list);
    $$=printnode;
    
    
    //PrintStatement//std::cout<<std::endl;  /* interpreter.PrintBuffer("\n"); */
}
;

printlist   :   printItem { auto a = new ExpressionList(); a->list.push_back($1); $$=a;}
|   printlist ';' printItem { auto a  = static_cast<ExpressionList*>$1; a->list.push_back($3); $$=a; }
;

printItem   :   strexpr
|   numexpr
;



letStatement     : LET VAR '=' numexpr  {
    
   // Value value;
   // value.valutype = Value::Evaluetype::floattype;
   // value.numVal = $4;
    //varTable[$2]=value;
    
   
   auto l = new LetStatement;
   l->variablename= $2;
   l->rvalue =    std::unique_ptr<Expression>($4);

    $$=l;

   
   //trace<<"let "<<$2<<" = "<<$4<<std::endl;
   
}
| LET SVAR '=' strexpr {
    
    auto l = new LetStatement;
    l->variablename= $2;
    l->rvalue =    std::unique_ptr<Expression>($4);
    
    $$=l;
}


endstatement    : END { $$.nodeVal = new EndStatement(); }
;

inputStatement  : INPUT inputList { $$.nodeVal=$2;}
| INPUT STRING_LITERAL ';'  inputList
{
    auto readnode = static_cast<ReadStatement*>($4);
    readnode->prompt = $2;
    $$.nodeVal=readnode;
}
;

inputList : inputItem
{
    auto readnode = new ReadStatement();
    readnode->variableList.push_back($1);
    $$=readnode;

}
| inputList ';' inputItem
{

    auto readnode = static_cast<ReadStatement*>($1);
    readnode->variableList.push_back($3);
    $$ = $1;
}
;

inputItem       : VAR|SVAR;


forStataement 	: FOR VAR '=' numexpr TO numexpr  {
    
    std::string varName = $2;
    float step = 1;
    
    ForStatment::ForBlock forBlock;
    
    forBlock.forVar = varName;
    forBlock.forBegin =  std::unique_ptr<Expression>($4);
    
    TerminalExpression t;
    t.sub.numVal = step;
    
    
    forBlock.forStep =  std::unique_ptr<Expression>(&t);
    forBlock.forEnd = std::unique_ptr<Expression>($6);
    
    auto fornode = new ForStatment();
    fornode->forBlock.Set(std::move(forBlock));
    $$=fornode;


    
}
| FOR VAR '=' numexpr TO numexpr STEP numexpr
{
    std::string varName = $2;
    
    ForStatment::ForBlock forBlock;
    
    forBlock.forVar = varName;
    forBlock.forBegin =  std::unique_ptr<Expression>($4);
    forBlock.forStep =  std::unique_ptr<Expression>($8);
    forBlock.forEnd = std::unique_ptr<Expression>($6);
    
    auto fornode = new ForStatment();
    fornode->forBlock.Set(std::move(forBlock));
    $$=fornode;
}
;



nextStatement   : NEXT VAR {
    
    auto node = new NextStatement();
    $$=node;
    
  
}
;






boolExression : numexpr '=' numexpr {   $$ = ($1 == $3); }
| numexpr '>' numexpr {   $$ = ($1 > $3); }
| numexpr '<' numexpr {   $$ = ($1 < $3); }
| strexpr '=' strexpr {   $$ = ($1 == $3); }
;




strexpr     : '(' strexpr ')'
{
    $$ = $2;
}
| strexpr '+' strexpr
{
    
    BainaryExpression *e=new BainaryExpression ;
    e->left = std::unique_ptr<Expression>($1);
    
    e->mOperator = BainaryExpression::operatorType::plus;
    
    e->right = std::unique_ptr<Expression>($3);
    
    $$=e;

    //trace<<$1<<"+"<<$3<<" = "<<$$<<std::endl;


    
}
| STRING_LITERAL {
    
    auto  t =new TerminalExpression;
    t->sub.stringVal = $1;
    t->sub.valutype = Value::Evaluetype::stringtype;
    $$ = t;

}
| SVAR {
    GetExpression *g =new GetExpression;
    g->varName = $1;
    
    $$ = g;

}

;





numexpr    :   '(' numexpr ')'
{
    //$$ = $2;
    
    
    auto e=new UnaryExpression ;
    e->sub = std::unique_ptr<Expression>($2);
    
    e->mOperator = UnaryExpression::operatorType::grouping;
    
    
   // trace<<"("<<$2<<") ="<<$$<<std::endl;
   
   
   
}
|   numexpr '*' numexpr
{
    

    BainaryExpression *e=new BainaryExpression ;
    e->left = std::unique_ptr<Expression>($1);
    
    e->mOperator = BainaryExpression::operatorType::multiply;
    
    e->right = std::unique_ptr<Expression>($3);

    //trace<<$1<<"*"<<$3<<"= "<<$$<<std::endl;
    $$= e;
}
|   numexpr '/' numexpr
{
    //$$ = $1 / $3;
    
    
    
    BainaryExpression *e=new BainaryExpression ;
    e->left = std::unique_ptr<Expression>($1);
    
    e->mOperator = BainaryExpression::operatorType::devide;
    
    e->right = std::unique_ptr<Expression>($3);
    $$=e;
    
    //trace<<$1<<"/"<<$3<<"= "<<$$<<std::endl;

}
|   numexpr '%' numexpr
{
 //   $$ = $1 % $3;
}
|   numexpr '+' numexpr
{
   // $$ = $1 + $3;
   
   
   BainaryExpression *e=new BainaryExpression ;
   e->left = std::unique_ptr<Expression>($1);
   
   e->mOperator = BainaryExpression::operatorType::plus;
   
   e->right = std::unique_ptr<Expression>($3);
   
   $$=e;

// trace<<$1<<"+"<<$3<<"= "<<$$<<std::endl;


}
|   numexpr '-' numexpr
{
    BainaryExpression *e=new BainaryExpression ;
    e->left = std::unique_ptr<Expression>($1);
    
    e->mOperator = BainaryExpression::operatorType::minus;
    
    e->right = std::unique_ptr<Expression>($3);
   // $$ = $1 - $3;
   // trace<<$1<<"-"<<$3<<"=" <<$$<<std::endl;
}

|NUMBER {
    auto  t =new TerminalExpression;
    t->sub.numVal = $1;
    $$ = t;
}
|REAL_NUMBER {
    
    auto  t =new TerminalExpression;
    t->sub.numVal = $1;
    $$ = t;
}
|VAR    {
    
    GetExpression *g =new GetExpression;
    g->varName = $1;
   
   $$ = g;
}
;



%%
void yyerror( Statement** statement, const char * error)
{
    
    *statement = new ErrorStatement(error);
    

}

extern "C" int yywrap()
{
    return 1;
}

/*
 Parser(Scanner scanner,
Interpreter interpreter)
: base(scanner)
{
    this.interpreter = interpreter;
    
}
*/